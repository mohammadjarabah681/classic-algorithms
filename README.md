<h1 align="center">Classic Algorithms</h1>

## Overview

A collection of classic algorithms including sorting, searching, divide-and-conquer, greedy, dynamic programming, and graph traversal algorithms implemented in Python 3.10. This project has been finished while learning the *Design and Analysis of Algorithms from Scratch* with [Ahmed Metwally](https://www.linkedin.com/in/metwally), a cloud-native architect, at [Cloud Native Base Camp](https://cloudnativebasecamp.com).

## Algorithms

<div align="center">

| Name | Description | File(s) |
| :- | :- | :- |
| Circle Area | Calculates the circle area for the given circle dimensions. | [flowchart](./algorithms/01-circle-area/algorithm-flowchart.jpg) • [source code](./algorithms/01-circle-area/source-code.py) |
| Parallelogram Area | Calculates the parallelogram area for the given parallelogram dimensions. | [flowchart](./algorithms/02-parallelogram-area/algorithm-flowchart.jpg) • [source code](./algorithms/02-parallelogram-area/source-code.py) |
| Trapezoid Area | Calculates the trapezoid area for the given trapezoid dimensions. | [flowchart](./algorithms/03-trapezoid-area/algorithm-flowchart.jpg) • [source code](./algorithms/03-trapezoid-area/source-code.py) |
| Standard Deviation | Calculates the standard deviation for the given sequence of items. | [flowchart](./algorithms/04-standard-deviation/algorithm-flowchart.jpg) • [source code](./algorithms/04-standard-deviation/source-code.py) |
| Pearson Correlation Coefficient | Calculates the pearson correlation coefficient for the given sequences of items. **Note**: Both given sequences MUST have the same length of items. | [flowchart](./algorithms/05-pearson-correlation-coefficient/algorithm-flowchart.jpg) • [source code](./algorithms/05-pearson-correlation-coefficient/source-code.py) |
| Insertion Sort | Sorts the elements of the given array by repeatedly inserting next element into sorted part. | [flowchart](./algorithms/06-insertion-sort/algorithm-flowchart.jpg) • [source code](./algorithms/06-insertion-sort/source-code.py) |
| Merge Sort | Sorts the elements of the given array by dividing array, recursively sorting halves, and merging sorted halves. Both of "*Divide & Conquer*" and "*Recursion*" design techniques are used. | [flowchart](./algorithms/07-merge-sort/algorithm-flowchart.jpg) • [source code](./algorithms/07-merge-sort/source-code.py) |
| Binary Search | Searches for a target value within a given sorted array. It returns the index of the target element if it's found in the array, otherwise, it returns `-1`. **Note**: The given array MUST be sorted. | [flowchart](./algorithms/08-binary-search/algorithm-flowchart.jpg) • [source code](./algorithms/08-binary-search/source-code.py) |
| Segregate Positive and Negative Numbers | Segregates the elements of the given array, such that all negative numbers appear before the positive numbers while maintaining the relative order of negative and positive numbers within their respective groups. The "*Merge Sort*" technique is used to rearrange the elements, also both of "*Divide & Conquer*" and "*Recursion*" design techniques are used. **Note**: zero treats the same as the positive numbers. | [flowchart](./algorithms/09-segregate-numbers/algorithm-flowchart.jpg) • [source code](./algorithms/09-segregate-numbers/source-code.py) |
| Activity Selection Problem | Selects the maximum number of non-overlapping activities by iteratively picking the next activity that starts after the last selected one. It accepts two arrays, one for start time, and the other for finish/end time. The "*Greedy Method/Strategy*" design technique is used to solve this combinatorial optimization problem. **Note**: The given arrays MUST be sorted by finish/end time. Also, both given arrays MUST have the same length of items. | [flowchart](./algorithms/10-activity-selection-problem/algorithm-flowchart.jpg) • [source code](./algorithms/10-activity-selection-problem/source-code.py) |
| Character Frequencies | Calculates the frequency of characters in a given string for *ASCII* code points only. | [flowchart](./algorithms/11-character-frequencies/algorithm-flowchart.jpg) • [source code](./algorithms/11-character-frequencies/source-code.py) |
| Sorted Character Frequencies | Calculates the frequency of characters in a given string for ASCII and UTF-8 code points, and support a method to sort the results ascending by the values of character frequencies. | [source code](./algorithms/12-sorted-character-frequencies/source-code.py) |
| Huffman Coding | A lossless data compression algorithm that assigns variable-length codes to input characters, with shorter codes for more frequent characters. It minimizes the total number of bits needed to represent a string. Both of "*Greedy Method/Strategy*" and "*Recursion*" design techniques are used. Also, the "*Min-heap*", "*Priority Queue*", and "*Hash Table*" data structures are used. | [source code](./algorithms/13-huffman-coding/source-code.py) |
| Fractional Knapsack Problem  | Selects from the given sequence of items greedily to fill the knapsack, maximizing profit even by taking fractional amounts of items if needed. The "*Greedy Method/Strategy*" design technique is used to solve this optimization problem. | [source code](./algorithms/14-fractional-knapsack-problem/source-code.py) |
| Stagecoach Problem | Finds the minimum cost path from the starting station to the destination by systematically evaluating each possible route. The "*Dynamic Programming*" design technique is employed to solve this optimization problem, ensuring that the solution is optimal by breaking down the problem into overlapping subproblems and solving each efficiently. | [source code](./algorithms/15-stagecoach-problem/source-code.py) |
| Longest Common Subsequence | Determines the longest subsequence common to all given sequences, without changing the order of the elements. The "*Dynamic Programming*" design technique is used to solve this optimization problem by building solutions to smaller subproblems and combining them to find the optimal subsequence. | [source code](./algorithms/16-longest-common-subsequence/source-code.py) |
| 0/1 Knapsack Problem | Selects items from a given set to maximize profit without exceeding the knapsack's capacity, where each item can either be included or excluded (no fractional items allowed). The "*Dynamic Programming*" design technique is used to solve this optimization problem by building a table of solutions to subproblems based on item inclusion and capacity constraints. | [source code](./algorithms/17-01-knapsack-problem/source-code.py) |
| Prim’s Minimum Spanning Tree | Finds the Minimum Spanning Tree (MST) of a weighted, undirected graph. The "*Greedy Method/Strategy*" design technique is used to solve this optimization problem. | [source code](./algorithms/18-prim-minimum-spanning-tree/source-code.py) |
| Breadth-first Search (BFS) | A graph traversal algorithm performs a Breadth-first Search (BFS) on an undirected graph. It starts from the first vertex, visits all neighboring vertices level by level using a "*Queue*" and "*Hash Table*" data structures, and marks each as visited. | [source code (i)](./algorithms/19-breadth-first-search/simple-version.py) • [source code (ii)](./algorithms/19-breadth-first-search/optimized-version.py) |
| Depth-first Search (DFS) | A graph traversal algorithm performs a Depth-first Search (DFS) on an undirected graph. It starts from the first vertex and explores as far as possible along each branch before backtracking. A "*Recursion*" design techniques is used to manage exploration. | [source code](./algorithms/20-depth-first-search/source-code.py) |
| Dijkstra’s Shortest Path | Finds the shortest path from a source vertex to a destination vertex in a weighted, directed graph. A "*Greedy Method/Strategy*"  design technique is used to ensure that the shortest path is built step by step. | [source code](./algorithms/21-dijkstra-shortest-path/source-code.py) |

</div>

# License

This project is licensed under the [MIT License](./LICENSE).
